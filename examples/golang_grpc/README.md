# golang_grpc

This is a template of making a gRPC service in golang. To run this sample project on local machine:
```BASH
make mariadb10.3 # wait until you can connect to the db with `make conndb`
make initdb # wait until all successful
make up # wait until the container is healthy

# Try access the API using curl:
./testscripts/FirstService.GetFirst.sh
```

## Tools being used
1. [gRPC](https://godoc.org/google.golang.org/grpc)
2. protobuf
3. [protobuf, protoc](https://github.com/google/protobuf/releases)
4. [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway/)
5. [go-swagger](https://github.com/go-swagger/go-swagger)
7. [go-grpc-middleware validator](https://github.com/grpc-ecosystem/go-grpc-middleware/tree/master/validator)
8. [Redoc](https://github.com/Rebilly/ReDoc)
9. [dep](https://github.com/golang/dep)
10. [gofmt](https://golang.org/cmd/gofmt/)
11. [prometheus golang library](https://github.com/prometheus/client_golang/)
12. [Docker](https://www.docker.com/)
13. [GNU make](https://www.gnu.org/software/make/)
14. [hey](https://github.com/rakyll/hey)
15. [golang custom image](https://hub.docker.com/r/minixxie/golang/)
16. [nginx-proxy](https://hub.docker.com/r/jwilder/nginx-proxy/)

### gRPC
gRPC is a remote procedure call protocol using the power of HTTP/2.0 binary protocol + protobuf binary serialization protocol as the communication medium.

### protobuf
protobuf is a binary serialization protocol. compared with the TEXT serialization protocol JSON, it has higher performance.

### protoc
protoc is a protobuf files (*.proto) compiler. It helps us compile *.proto to *.go.

### grpc-gateway
grpc-gateway is a proxy library that can help us serve JSON text protocol on top of the binary gRPC protocol. This introduce compatibility with HTTP/1.0 + JSON text protocol. So clients have choice of HTTP/1.0 + JSON in addition to HTTP/2.0 + protobuf. This library also has a tool called protoc-gen-swagger which will generate swagger.json specification from the *.proto files.

### go-swagger
A tool similar to Swagger UI but it is in golang. It serve the API documentation by reading the swagger.json. It has two choices: Swagger or Redoc. We are using Redoc.

### go-grpc-middleware validator
This is a validation library allowing us to write validation rules right in the *.proto files. The middleware will check and return error to the clients.

### Redoc
Swagger UI similar tool, for generating awesome API documentation.

### dep
Official golang dependency management tool.

### gofmt
Format the golang source code according to official rules. Docker image build will be interrupted if source codes are not conforming to the official rules.

### prometheus golang library
Allow us to expose metrics to prometheus monitoring tool. We use it to expose :8081/metrics endpoint.

### Docker
We use docker and docker-compose to isolate the server process from the server environment.

### GNU make
We use traditional make command for convenience invoking frequently used commands.

### hey
A ab (apache benchmark) like tool in golang to test concurrency result.

### golang custom image
[Golang image](https://hub.docker.com/r/minixxie/golang/) base on the official one, customized by the author.

### nginx-proxy
A customized nginx docker image, which will auto-generate nginx server configuration files by scanning other upstream containers.

## Developers Notes
1. Using Makefile, you may need to setup databases, for example:
    ```
    $ make mariadb10.0
    ```
    This will download mariadb10.0 image and spin up an container. Other examples could be:
    ```
    $ make redis
    $ make mongo
    $ make postgis
    $ make tidb
    $ ...
    ```
    You may type `make help` to see what you can do with the Makefile.
2. Using Makefile, please run `make nginx` to spin up the `nginx-proxy` container, to act as a reverse proxy to the HTTP/1.0 upstream in this service.
3. `./src/proto/v1/v1.proto` is being kept as one proto file, since protoc tool will generate one swagger.json per proto file, so far either Swagger or Redoc will have difficulty to show multiple swagger.json into one documentation. So we should put all *Service and message into this one proto file for now.
4. Currently the container ports are allocated as:
    * 80: HTTP/1.0 + JSON interface
    * 8080: HTTP/2.0 + protobuf gRPC interface
    * 8081: where /metrics is serving data for prometheus
5. `./src/services/` is the folder for putting endpoints handlers. Handlers are grouped into gRPC "Service". Each gRPC "Service" struct has to implement(inherit) from the interface generated by protoc. Each handler is separated into one file which has the name readable as the rpc name.
6. In profo file, each rpc is configured to have a readable HTTP/1.0 URL which represent the rpc name directly. (e.g. /v1/FirstService/Echo for rpc FirstService::Echo())
7. `./src/vendor/` is the folder for putting vendor files when running `dep` tool.
8. `./testscripts/` is where scripts are located for aiding the testing.
9. In `./testscripts/`, each rpc at least has two scripts. One for doing "curl" test, another one for doing "hey" (ab like) concurrency test. There should also be a `./metrics.sh` script for testing the `/metrics` endpoint.
10. `Dockerfile` and `docker-compose.local.yml` are files for running the service into docker container.
11. Since `local_network` docker network is needed, whenever typing `make up`, it will automatically create for you. You can also type `make local_network` explicitly to create.
12. Type `make help` to see what can we do with the `Makefile`.
13. Type `make redoc` to generate and serve the API documentation.
14. `Gopkg.lock` and `Gopkg.toml` are files maintained by `dep` tool. Whenever new import path is added into any *.go code, run `make dep-ensure` to update these two files.
15. Makefile targets can be concatenated. e.g. this command could be frequently used:
    ```
    $ make up logs
    ```
    It will spin up the container and then tail the docker logs.
16. `make init` and `make dep-init` should only be used when initializing a brand new empty project. Use only when you know what's happening.
17. `make rm-img` could be regularly used to clean all the `<none>` images and failed containers.
18. Steps to add one new rpc endpoint:
    * Add an rpc in a `service` in `./src/proto/v1/v1.proto`, together with the `XXXRequest` and `XXXResponse` messages.
    * Add an file in `./src/services/`, using readable filename that tells the rpc name directly. Add a handler function inside.
    * Start write code in the handler function.
    * If you might use any database, may consider adding `./src/models/` folder for putting your model class there. Import the models package in the handler file and then call your model class' function there.
19. Rule of thumb: KISS (Keep it simple and Stupid)
20. TL;DR: run these when you fetch the repo as fresh:
    ```
    $ make initdb
    $ make up logs
    $ ./testscripts/FirstService.Echo.sh
    ```  
